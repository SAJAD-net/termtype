# Python Decorators - Advanced Function Patterns

import time
import functools

def timer_decorator(func):
    """Measure and print function execution time."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return wrapper

def memoize(func):
    """Cache function results for repeated calls."""
    cache = {}
    @functools.wraps(func)
    def wrapper(*args):
        if args in cache:
            print(f"Returning cached result for {args}")
            return cache[args]
        result = func(*args)
        cache[args] = result
        return result
    return wrapper

@timer_decorator
@memoize
def slow_fibonacci(n):
    """Slow recursive Fibonacci (memoized for speed)."""
    if n <= 1:
        return n
    return slow_fibonacci(n-1) + slow_fibonacci(n-2)

# Test the decorated function
print("Calculating Fibonacci(35)...")
result = slow_fibonacci(35)
print(f"Result: {result}")
---

def validate_positive(func):
    """Decorator to validate positive arguments."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        for arg in args:
            if isinstance(arg, (int, float)) and arg < 0:
                raise ValueError(f"Negative argument not allowed: {arg}")
        return func(*args, **kwargs)
    return wrapper

def retry(max_attempts=3, delay=1):
    """Decorator to retry failed functions."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise e
                    print(f"Attempt {attempt + 1} failed. Retrying...")
                    time.sleep(delay)
            return None
        return wrapper
    return decorator

@validate_positive
def calculate_square_root(x):
    """Calculate square root of positive numbers."""
    return x ** 0.5

@retry(max_attempts=3, delay=1)
def unreliable_network_call():
    """Simulate an unreliable network call."""
    import random
    if random.random() < 0.7:  # 70% chance of failure
        raise ConnectionError("Network timeout")
    return "Success!"

# Test the decorators
print(f"Square root of 25: {calculate_square_root(25)}")

try:
    result = unreliable_network_call()
    print(f"Network call result: {result}")
except Exception as e:
    print(f"All retries failed: {e}")
